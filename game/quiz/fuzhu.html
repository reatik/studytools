<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>题库管理系统</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .control-panel {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .btn {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            min-width: 80px;
        }
        .btn:hover {
            background-color: #45a049;
        }
        .btn-danger {
            background-color: #f44336;
        }
        .search-box {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 0;
        }
        .search-box input {
            flex-grow: 1;
            padding: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            cursor: pointer;
            position: relative;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"], textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        .option-item {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .options-display {
            margin-top: 5px;
        }
        .correct-option {
            color: red;
            font-weight: bold;
        }
        .selected-row {
            background-color: #e3f2fd !important;
        }
        .bulk-edit-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .history-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #f5f5f5;
            border-radius: 4px;
            cursor: pointer;
        }
        .history-item:hover {
            background-color: #e0e0e0;
        }
        .sort-icon {
            margin-left: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 5px;
        }
        .category-count {
            color: #666;
            font-size: 0.9em;
            margin-left: 5px;
        }
        .id-column {
            width: 60px;
            text-align: center;
        }
        .batch-add-area {
            width: 100%;
            height: 300px;
            font-family: monospace;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 8px 15px;
            background-color: #ddd;
            border: none;
            cursor: pointer;
        }
        .tab-button.active {
            background-color: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .new-category-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .new-category-input input {
            width: 150px;
        }
        .duplicate-checkbox {
            margin-right: 10px;
        }
        .duplicate-controls {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f8ff;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>题库管理系统</h1>
        
        <div class="control-panel">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="搜索题目...">
                <button class="btn" onclick="searchQuestions()">搜索</button>
                <button class="btn" onclick="clearSearch()">清除</button>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="saveToJS()">保存题库</button>
                <button class="btn" onclick="showAddQuestionModal()">添加题目</button>
                <button class="btn" onclick="startBulkEdit()">批量修改</button>
                <button class="btn" onclick="showHistory()" id="undoBtn" disabled>撤销</button>
                <button class="btn" onclick="checkDuplicates()">题目查重</button>
                
                <select id="categoryFilter" onchange="filterByCategory()" style="width: 200px; padding: 8px;">
                    <option value="">所有分类</option>
                </select>
            </div>
        </div>
        
        <!-- 批量编辑控制栏 -->
        <div id="bulkEditControls" class="bulk-edit-controls" style="display: none;">
            <span style="font-weight: bold;">批量编辑模式：</span>
            <button class="btn" onclick="selectAllForBulkEdit()">全选</button>
            <button class="btn" onclick="deselectAllForBulkEdit()">取消全选</button>
            <select id="bulkEditAction" style="width: 150px; padding: 8px;">
                <option value="changeCategory">修改分类</option>
                <option value="delete">删除题目</option>
            </select>
            <div id="categoryEditContainer" style="display: none;">
                <div class="new-category-input">
                    <select id="newCategory" style="width: 200px; padding: 8px;"></select>
                    <span>或</span>
                    <input type="text" id="newCategoryInput" placeholder="输入新分类名称">
                </div>
            </div>
            <button class="btn" onclick="applyBulkEdit()">应用</button>
            <button class="btn" onclick="cancelBulkEdit()">取消</button>
            <span id="selectedCount">已选择 0 个题目</span>
        </div>
        
        <div id="questionTableContainer">
            <table id="questionTable">
                <thead>
                    <tr>
                        <th class="id-column" onclick="sortTable('id')">ID <span class="sort-icon">↕</span></th>
                        <th onclick="sortTable('question')">题目 <span class="sort-icon">↕</span></th>
                        <th>选项</th>
                        <th onclick="sortTable('category')">分类 <span class="sort-icon">↕</span></th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody id="questionTableBody">
                    <!-- 题目列表将在这里动态生成 -->
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- 添加题目模态框（带选项卡） -->
    <div id="addQuestionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAddModal()">&times;</span>
            <h2>添加题目</h2>
            
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('single')">单题添加</button>
                <button class="tab-button" onclick="switchTab('batch')">批量添加</button>
            </div>
            
            <!-- 单题添加 -->
            <div id="singleTab" class="tab-content active">
                <form id="questionForm">
                    <input type="hidden" id="questionId">
                    
                    <div class="form-group">
                        <label for="questionText">题目:</label>
                        <textarea id="questionText" required></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>选项:</label>
                        <div id="optionsContainer">
                            <!-- 选项将在这里动态生成 -->
                        </div>
                        <button type="button" class="btn" onclick="addOption()">添加选项</button>
                    </div>
                    
                    <div class="form-group">
                        <label for="correctAnswer">正确答案:</label>
                        <select id="correctAnswer" required>
                            <!-- 选项将在这里动态生成 -->
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="explanation">解析:</label>
                        <textarea id="explanation"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="category">分类:</label>
                        <input type="text" id="category" list="categoryList">
                        <datalist id="categoryList">
                            <!-- 分类列表将在这里动态生成 -->
                        </datalist>
                    </div>
                    
                    <div class="form-group">
                        <button type="button" class="btn" onclick="saveQuestion()">保存</button>
                        <button type="button" class="btn" onclick="closeAddModal()">取消</button>
                    </div>
                </form>
            </div>
            
            <!-- 批量添加 -->
            <div id="batchTab" class="tab-content">
                <div class="form-group">
                    <label for="batchQuestions">批量添加题目 (JSON格式):</label>
                    <textarea id="batchQuestions" class="batch-add-area" placeholder='[
    {
        "question": "题目内容",
        "options": ["选项1", "选项2", "选项3", "选项4"],
        "answer": 1,
        "explanation": "解析内容",
        "category": "分类名称"
    },
    // 更多题目...
]'></textarea>
                </div>
                <div class="form-group">
                    <button type="button" class="btn" onclick="batchAddQuestions()">批量添加</button>
                    <button type="button" class="btn" onclick="closeAddModal()">取消</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 编辑题目模态框 -->
    <div id="editQuestionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditModal()">&times;</span>
            <h2 id="editModalTitle">编辑题目</h2>
            
            <form id="editQuestionForm">
                <input type="hidden" id="editQuestionId">
                
                <div class="form-group">
                    <label for="editQuestionText">题目:</label>
                    <textarea id="editQuestionText" required></textarea>
                </div>
                
                <div class="form-group">
                    <label>选项:</label>
                    <div id="editOptionsContainer">
                        <!-- 选项将在这里动态生成 -->
                    </div>
                    <button type="button" class="btn" onclick="addEditOption()">添加选项</button>
                </div>
                
                <div class="form-group">
                    <label for="editCorrectAnswer">正确答案:</label>
                    <select id="editCorrectAnswer" required>
                        <!-- 选项将在这里动态生成 -->
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="editExplanation">解析:</label>
                    <textarea id="editExplanation"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="editCategory">分类:</label>
                    <input type="text" id="editCategory" list="categoryList">
                </div>
                
                <div class="form-group">
                    <button type="button" class="btn" onclick="updateQuestion()">更新</button>
                    <button type="button" class="btn" onclick="closeEditModal()">取消</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- 历史记录模态框 -->
    <div id="historyModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close" onclick="closeHistoryModal()">&times;</span>
            <h2>操作历史</h2>
            <div id="historyList" style="max-height: 400px; overflow-y: auto;">
                <!-- 历史记录将在这里动态生成 -->
            </div>
            <div style="margin-top: 15px; text-align: right;">
                <button class="btn" onclick="clearHistory()">清空历史</button>
                <button class="btn" onclick="closeHistoryModal()">关闭</button>
            </div>
        </div>
    </div>

    <script>
// 全局变量
let questionBank = [];
let filteredQuestions = [];
let selectedQuestions = [];
let history = [];
let isBulkEditMode = false;
let sortColumn = 'id';
let sortDirection = 1;
let duplicateResults = [];

// 页面加载时初始化
window.onload = function() {
    loadTikuJS();
};

function loadTikuJS() {
    const script = document.createElement('script');
    script.src = 'tiku.js';
    script.onload = function() {
        if (typeof questionBank !== 'undefined') {
            // 确保每道题目都有ID
            questionBank = questionBank.map((q, index) => {
                return {
                    id: index + 1, // 从1开始的顺序ID
                    ...q
                };
            });
            initializeQuestions(questionBank);
        } else {
            alert('错误: tiku.js中没有定义questionBank变量');
        }
    };
    script.onerror = function() {
        alert('错误: 无法加载tiku.js文件，请确保文件存在于同一目录下');
    };
    document.head.appendChild(script);
}

// 初始化题目数据
function initializeQuestions(importedQuestions) {
    if (!Array.isArray(importedQuestions)) {
        alert('错误: questionBank不是一个数组');
        return;
    }
    
    questionBank = importedQuestions;
    filteredQuestions = [...questionBank];
    renderQuestionTable();
    updateCategoryFilter();
    updateHistoryButton();
}

// 渲染题目表格
function renderQuestionTable() {
    const tableBody = document.getElementById('questionTableBody');
    tableBody.innerHTML = '';
    
    // 排序
    filteredQuestions.sort((a, b) => {
        if (a[sortColumn] < b[sortColumn]) return -1 * sortDirection;
        if (a[sortColumn] > b[sortColumn]) return 1 * sortDirection;
        return 0;
    });
    
    // 更新排序图标
    updateSortIcons();
    
    filteredQuestions.forEach(question => {
        const row = document.createElement('tr');
        row.dataset.id = question.id;
        
        // 如果是批量编辑模式且题目被选中，添加选中样式
        if (isBulkEditMode && selectedQuestions.includes(question.id)) {
            row.classList.add('selected-row');
        }
        
        // 格式化选项显示
        const optionsHtml = question.options.map((opt, idx) => {
            return `<div class="${idx === question.answer ? 'correct-option' : ''}">${String.fromCharCode(65 + idx)}. ${opt}</div>`;
        }).join('');
        
        row.innerHTML = `
            <td class="id-column">${question.id}</td>
            <td>${question.question}</td>
            <td class="options-display">${optionsHtml}</td>
            <td>${question.category}</td>
            <td class="action-buttons">
                <button class="btn" onclick="editQuestion(${question.id})">编辑</button>
                <button class="btn btn-danger" onclick="deleteSingleQuestion(${question.id})">删除</button>
            </td>
        `;
        
        // 批量编辑模式下添加点击选择功能
        if (isBulkEditMode) {
            row.onclick = function(e) {
                // 如果点击的是按钮，则不触发选择
                if (e.target.tagName === 'BUTTON') return;
                
                const questionId = parseInt(this.dataset.id);
                toggleQuestionSelection(questionId);
                this.classList.toggle('selected-row');
                updateSelectedCount();
            };
        }
        
        tableBody.appendChild(row);
    });
}

// 更新分类过滤器
function updateCategoryFilter() {
    const categoryFilter = document.getElementById('categoryFilter');
    const categoryList = document.getElementById('categoryList');
    const newCategorySelect = document.getElementById('newCategory');
    
    // 获取所有不重复的分类
    const categories = [...new Set(questionBank.map(q => q.category))];
    
    // 计算每个分类的题目数量
    const categoryCounts = {};
    questionBank.forEach(q => {
        categoryCounts[q.category] = (categoryCounts[q.category] || 0) + 1;
    });
    
    // 清空现有选项
    categoryFilter.innerHTML = '<option value="">所有分类</option>';
    categoryList.innerHTML = '';
    newCategorySelect.innerHTML = '';
    
    // 添加分类选项（带题目计数）
    categories.forEach(category => {
        const count = categoryCounts[category] || 0;
        
        // 分类筛选器
        const option = document.createElement('option');
        option.value = category;
        option.textContent = `${category} (${count}题)`;
        categoryFilter.appendChild(option);
        
        // 分类数据列表
        const datalistOption = document.createElement('option');
        datalistOption.value = category;
        categoryList.appendChild(datalistOption);
        
        // 批量修改分类选择器
        const newCategoryOption = document.createElement('option');
        newCategoryOption.value = category;
        newCategoryOption.textContent = `${category} (${count}题)`;
        newCategorySelect.appendChild(newCategoryOption);
    });
}

// 按分类过滤题目
function filterByCategory() {
    const category = document.getElementById('categoryFilter').value;
    
    if (category === '') {
        filteredQuestions = [...questionBank];
    } else {
        // 去掉括号和题目数量部分
        const pureCategory = category.replace(/$\d+题$$/, '').trim();
        filteredQuestions = questionBank.filter(q => q.category === pureCategory);
    }
    
    renderQuestionTable();
}

// 排序表格
function sortTable(column) {
    if (sortColumn === column) {
        sortDirection *= -1; // 切换排序方向
    } else {
        sortColumn = column;
        sortDirection = 1; // 默认升序
    }
    
    renderQuestionTable();
}

// 更新排序图标
function updateSortIcons() {
    const headers = document.querySelectorAll('th');
    headers.forEach(header => {
        const icon = header.querySelector('.sort-icon');
        if (icon) {
            if (header.textContent.trim().includes(sortColumn)) {
                icon.textContent = sortDirection === 1 ? '↑' : '↓';
            } else {
                icon.textContent = '↕';
            }
        }
    });
}

// 搜索题目
function searchQuestions() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    
    if (searchTerm === '') {
        filteredQuestions = [...questionBank];
    } else {
        filteredQuestions = questionBank.filter(q => 
            q.question.toLowerCase().includes(searchTerm) || 
            (q.explanation && q.explanation.toLowerCase().includes(searchTerm)) ||
            q.category.toLowerCase().includes(searchTerm)
        );
    }
    
    renderQuestionTable();
}

// 清除搜索
function clearSearch() {
    document.getElementById('searchInput').value = '';
    filteredQuestions = [...questionBank];
    renderQuestionTable();
}

// 保存到JS文件（改进版）
function saveToJS() {
    // 重新为所有题目分配顺序ID
    const sortedQuestions = [...questionBank].sort((a, b) => a.id - b.id);
    const questionsWithNewIds = sortedQuestions.map((q, index) => ({
        ...q,
        id: index + 1  // 从1开始的顺序ID
    }));
    
    // 生成JS文件内容
    let jsContent = `var questionBank = ${JSON.stringify(questionsWithNewIds, null, 2)};`;
    
    // 创建Blob对象
    const blob = new Blob([jsContent], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    
    // 创建下载链接
    const downloadAnchor = document.createElement('a');
    downloadAnchor.setAttribute('href', url);
    downloadAnchor.setAttribute('download', 'tiku.js');
    
    // 模拟点击下载
    document.body.appendChild(downloadAnchor);
    downloadAnchor.click();
    document.body.removeChild(downloadAnchor);
    
    // 释放URL对象
    setTimeout(() => {
        URL.revokeObjectURL(url);
    }, 100);
    
    alert('题库已保存为tiku.js文件，请替换原文件');
    
    // 更新本地题库
    questionBank = questionsWithNewIds;
    filteredQuestions = [...questionBank];
    renderQuestionTable();
    updateCategoryFilter();
}

// 切换选项卡
function switchTab(tabName) {
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`).classList.add('active');
    document.getElementById(`${tabName}Tab`).classList.add('active');
}

// 显示添加题目模态框
function showAddQuestionModal() {
    document.getElementById('addQuestionModal').style.display = 'block';
    document.getElementById('questionForm').reset();
    
    // 设置新ID
    const newId = questionBank.length > 0 ? Math.max(...questionBank.map(q => q.id)) + 1 : 1;
    document.getElementById('questionId').value = newId;
    
    // 清空选项
    document.getElementById('optionsContainer').innerHTML = '';
    document.getElementById('correctAnswer').innerHTML = '';
    
    // 添加两个默认选项
    addOption();
    addOption();
}

// 关闭添加题目模态框
function closeAddModal() {
    document.getElementById('addQuestionModal').style.display = 'none';
}

// 添加选项
function addOption(value = '', index = null) {
    const optionsContainer = document.getElementById('optionsContainer');
    const optionId = index !== null ? index : optionsContainer.children.length;
    
    const optionDiv = document.createElement('div');
    optionDiv.className = 'option-item';
    
    optionDiv.innerHTML = `
        <input type="text" class="option-input" value="${value}" placeholder="选项内容" data-index="${optionId}">
        <button type="button" class="btn btn-danger" onclick="removeOption(this)" style="margin-left: 5px;">删除</button>
    `;
    
    optionsContainer.appendChild(optionDiv);
    
    // 更新正确答案下拉框
    updateCorrectAnswerOptions();
}

// 删除选项
function removeOption(button) {
    const optionDiv = button.parentNode;
    optionDiv.remove();
    
    // 更新正确答案下拉框
    updateCorrectAnswerOptions();
}

// 更新正确答案下拉框
function updateCorrectAnswerOptions() {
    const correctAnswerSelect = document.getElementById('correctAnswer');
    const optionInputs = document.querySelectorAll('.option-input');
    
    correctAnswerSelect.innerHTML = '';
    
    optionInputs.forEach((input, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = input.value || `选项 ${index + 1}`;
        correctAnswerSelect.appendChild(option);
    });
}

// 保存题目
function saveQuestion() {
    const id = parseInt(document.getElementById('questionId').value);
    const questionText = document.getElementById('questionText').value.trim();
    const explanation = document.getElementById('explanation').value.trim();
    const category = document.getElementById('category').value.trim();
    const correctAnswer = parseInt(document.getElementById('correctAnswer').value);
    
    // 收集选项
    const options = [];
    const optionInputs = document.querySelectorAll('.option-input');
    
    optionInputs.forEach(input => {
        const optionText = input.value.trim();
        if (optionText) {
            options.push(optionText);
        }
    });
    
    // 验证数据
    if (!questionText) {
        alert('请输入题目内容');
        return;
    }
    
    if (options.length < 2) {
        alert('请至少添加两个选项');
        return;
    }
    
    if (isNaN(correctAnswer) || correctAnswer < 0 || correctAnswer >= options.length) {
        alert('请选择正确的答案');
        return;
    }
    
    if (!category) {
        alert('请输入分类');
        return;
    }
    
    // 创建题目对象
    const newQuestion = {
        id,
        question: questionText,
        options,
        answer: correctAnswer,
        explanation,
        category
    };
    
    // 添加到题库
    questionBank.push(newQuestion);
    filteredQuestions = [...questionBank];
    
    // 记录操作历史
    addHistory('add', null, newQuestion);
    
    // 更新界面
    renderQuestionTable();
    updateCategoryFilter();
    closeAddModal();
}

// 批量添加题目
function batchAddQuestions() {
    const batchText = document.getElementById('batchQuestions').value.trim();
    
    if (!batchText) {
        alert('请输入要添加的题目内容');
        return;
    }
    
    try {
        let newQuestions;
        // 检查是否是单个题目对象
        if (batchText.startsWith('{') && batchText.endsWith('}')) {
            newQuestions = [JSON.parse(batchText)];
        } else {
            newQuestions = JSON.parse(batchText);
        }
        
        if (!Array.isArray(newQuestions)) {
            alert('请输入有效的题目数组');
            return;
        }
        
        // 检查每个题目是否有必要字段
        const validQuestions = newQuestions.filter(q => {
            return q.question && q.options && q.options.length >= 2 && 
                   q.answer !== undefined && q.category;
        });
        
        if (validQuestions.length === 0) {
            alert('没有有效的题目可以添加');
            return;
        }
        
        if (validQuestions.length < newQuestions.length) {
            alert(`共 ${newQuestions.length} 道题目，其中 ${validQuestions.length} 道有效`);
        }
        
        // 获取当前最大ID
        let maxId = questionBank.length > 0 ? Math.max(...questionBank.map(q => q.id)) : 0;
        
        // 为每道新题目分配ID
        const questionsWithIds = validQuestions.map((q, index) => {
            return {
                id: maxId + index + 1,
                question: q.question,
                options: q.options,
                answer: q.answer,
                explanation: q.explanation || '',
                category: q.category
            };
        });
        
        // 记录操作历史
        addHistory('batchAdd', null, questionsWithIds);
        
        // 添加到题库
        questionBank.push(...questionsWithIds);
        filteredQuestions = [...questionBank];
        
        renderQuestionTable();
        updateCategoryFilter();
        
        alert(`成功添加 ${validQuestions.length} 道题目`);
        closeAddModal();
    } catch (e) {
        alert('解析JSON出错: ' + e.message);
    }
}

// 编辑题目
function editQuestion(id) {
    const question = questionBank.find(q => q.id === id);
    
    if (!question) return;
    
    document.getElementById('editModalTitle').textContent = `编辑题目 (ID: ${id})`;
    
    // 填充表单
    document.getElementById('editQuestionId').value = question.id;
    document.getElementById('editQuestionText').value = question.question;
    document.getElementById('editExplanation').value = question.explanation;
    document.getElementById('editCategory').value = question.category;
    
    // 填充选项
    const optionsContainer = document.getElementById('editOptionsContainer');
    optionsContainer.innerHTML = '';
    
    question.options.forEach((option, index) => {
        addEditOption(option, index);
    });
    
    // 填充正确答案
    const correctAnswerSelect = document.getElementById('editCorrectAnswer');
    correctAnswerSelect.innerHTML = '';
    
    question.options.forEach((option, index) => {
        const optionElement = document.createElement('option');
        optionElement.value = index;
        optionElement.textContent = option;
        correctAnswerSelect.appendChild(optionElement);
    });
    
    correctAnswerSelect.value = question.answer;
    
    document.getElementById('editQuestionModal').style.display = 'block';
}

// 添加编辑选项
function addEditOption(value = '', index = null) {
    const optionsContainer = document.getElementById('editOptionsContainer');
    const optionId = index !== null ? index : optionsContainer.children.length;
    
    const optionDiv = document.createElement('div');
    optionDiv.className = 'option-item';
    
    optionDiv.innerHTML = `
        <input type="text" class="edit-option-input" value="${value}" placeholder="选项内容" data-index="${optionId}">
        <button type="button" class="btn btn-danger" onclick="removeEditOption(this)" style="margin-left: 5px;">删除</button>
    `;
    
    optionsContainer.appendChild(optionDiv);
    
    // 更新正确答案下拉框
    updateEditCorrectAnswerOptions();
}

// 删除编辑选项
function removeEditOption(button) {
    const optionDiv = button.parentNode;
    optionDiv.remove();
    
    // 更新正确答案下拉框
    updateEditCorrectAnswerOptions();
}

// 删除单道题目（主界面使用）
function deleteSingleQuestion(id) {
    if (confirm('确定要删除这道题目吗？')) {
        const question = questionBank.find(q => q.id === id);
        if (question) {
            addHistory('delete', question, null);
            
            // 删除题目
            questionBank = questionBank.filter(q => q.id !== id);
            
            // 重新编号所有题目（从1开始连续编号）
            questionBank = questionBank.map((q, index) => ({
                ...q,
                id: index + 1
            }));
            
            filteredQuestions = [...questionBank];
            
            renderQuestionTable();
            updateCategoryFilter();
        }
    }
}

// 更新编辑正确答案下拉框
function updateEditCorrectAnswerOptions() {
    const correctAnswerSelect = document.getElementById('editCorrectAnswer');
    const optionInputs = document.querySelectorAll('.edit-option-input');
    
    correctAnswerSelect.innerHTML = '';
    
    optionInputs.forEach((input, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = input.value || `选项 ${index + 1}`;
        correctAnswerSelect.appendChild(option);
    });
}

// 关闭编辑题目模态框
function closeEditModal() {
    document.getElementById('editQuestionModal').style.display = 'none';
}

// 更新题目
function updateQuestion() {
    const id = parseInt(document.getElementById('editQuestionId').value);
    const questionText = document.getElementById('editQuestionText').value.trim();
    const explanation = document.getElementById('editExplanation').value.trim();
    const category = document.getElementById('editCategory').value.trim();
    const correctAnswer = parseInt(document.getElementById('editCorrectAnswer').value);
    
    // 收集选项
    const options = [];
    const optionInputs = document.querySelectorAll('.edit-option-input');
    
    optionInputs.forEach(input => {
        const optionText = input.value.trim();
        if (optionText) {
            options.push(optionText);
        }
    });
    
    // 验证数据
    if (!questionText) {
        alert('请输入题目内容');
        return;
    }
    
    if (options.length < 2) {
        alert('请至少添加两个选项');
        return;
    }
    
    if (isNaN(correctAnswer) || correctAnswer < 0 || correctAnswer >= options.length) {
        alert('请选择正确的答案');
        return;
    }
    
    if (!category) {
        alert('请输入分类');
        return;
    }
    
    // 更新题目
    const existingIndex = questionBank.findIndex(q => q.id === id);
    if (existingIndex >= 0) {
        const oldQuestion = questionBank[existingIndex];
        const newQuestion = {
            id,
            question: questionText,
            options,
            answer: correctAnswer,
            explanation,
            category
        };
        
        // 记录操作历史
        addHistory('update', oldQuestion, newQuestion);
        
        questionBank[existingIndex] = newQuestion;
        filteredQuestions = [...questionBank];
        
        renderQuestionTable();
        updateCategoryFilter();
        closeEditModal();
    }
}

// 删除题目
function deleteQuestion(id) {
    if (confirm('确定要删除这道题目吗？')) {
        const question = questionBank.find(q => q.id === id);
        if (question) {
            addHistory('delete', question, null);
            
            // 删除题目
            questionBank = questionBank.filter(q => q.id !== id);
            
            // 重新编号所有题目（从1开始连续编号）
            questionBank = questionBank.map((q, index) => ({
                ...q,
                id: index + 1
            }));
            
            filteredQuestions = [...questionBank];
            
            renderQuestionTable();
            updateCategoryFilter();
        }
    }
}

// 计算字符串相似度
function stringSimilarity(str1, str2) {
    // 移除标点符号和多余空格
    const cleanStr1 = str1.replace(/[^\w\u4e00-\u9fa5]/g, '').replace(/\s+/g, '');
    const cleanStr2 = str2.replace(/[^\w\u4e00-\u9fa5]/g, '').replace(/\s+/g, '');
    
    // 如果完全一致，直接返回1
    if (cleanStr1 === cleanStr2) return 1;
    
    // 计算Levenshtein距离
    const len1 = cleanStr1.length;
    const len2 = cleanStr2.length;
    const matrix = [];
    
    // 初始化矩阵
    for (let i = 0; i <= len1; i++) {
        matrix[i] = [i];
    }
    for (let j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }
    
    // 填充矩阵
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            const cost = cleanStr1[i - 1] === cleanStr2[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,     // 删除
                matrix[i][j - 1] + 1,     // 插入
                matrix[i - 1][j - 1] + cost  // 替换
            );
        }
    }
    
    // 计算相似度
    const distance = matrix[len1][len2];
    const maxLen = Math.max(len1, len2);
    return 1 - distance / maxLen;
}

function checkDuplicates() {
    const duplicates = [];
    const similarityThreshold = 0.8; // 相似度阈值
    
    // 比较所有题目对
    for (let i = 0; i < questionBank.length; i++) {
        for (let j = i + 1; j < questionBank.length; j++) {
            const q1 = questionBank[i];
            const q2 = questionBank[j];
            
            // 计算题目相似度
            const similarity = stringSimilarity(q1.question, q2.question);
            
            if (similarity >= similarityThreshold) {
                duplicates.push({
                    id1: q1.id,
                    question1: q1.question,
                    id2: q2.id,
                    question2: q2.question,
                    similarity: similarity,
                    checked: false // 默认不选中
                });
            }
        }
    }
    
    // 保存查重结果
    duplicateResults = duplicates;
    
    // 显示查重结果
    showDuplicateResults(duplicates);
}

// 显示查重结果
function showDuplicateResults(duplicates) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.style.maxWidth = '1000px';
    
    // 按相似度排序
    duplicates.sort((a, b) => b.similarity - a.similarity);
    
    let html = `
        <span class="close" onclick="this.parentNode.parentNode.style.display='none'">&times;</span>
        <h2>题目查重结果 (共 ${duplicates.length} 组相似题目)</h2>
        <div style="max-height: 500px; overflow-y: auto;">
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr>
                        <th style="width: 50px;">选择</th>
                        <th style="width: 45%;">原题</th>
                        <th style="width: 45%;">重复题</th>
                        <th style="width: 80px;">相似度</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    duplicates.forEach((dup, index) => {
        html += `
            <tr>
                <td style="text-align: center;">
                    <input type="checkbox" class="duplicate-checkbox" 
                           data-duplicate-id="${dup.id2}" 
                           onchange="updateDuplicateSelection(${index}, this.checked)">
                </td>
                <td>
                    <div><strong>ID: ${dup.id1}</strong></div>
                    <div>${dup.question1}</div>
                    <div class="action-buttons">
                        <button class="btn" onclick="editQuestion(${dup.id1})">编辑</button>
                    </div>
                </td>
                <td>
                    <div><strong>ID: ${dup.id2}</strong></div>
                    <div>${dup.question2}</div>
                    <div class="action-buttons">
                        <button class="btn" onclick="editQuestion(${dup.id2})">编辑</button>
                    </div>
                </td>
                <td style="text-align: center;">
                    ${(dup.similarity * 100).toFixed(1)}%
                </td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
        <div class="duplicate-controls" style="margin-top: 15px; display: flex; justify-content: space-between;">
            <div>
                <button class="btn" onclick="selectAllDuplicates(true)">全选</button>
                <button class="btn" onclick="selectAllDuplicates(false)">取消全选</button>
            </div>
            <div>
                <button class="btn btn-danger" onclick="deleteSelectedDuplicates()">删除选中重复题</button>
                <button class="btn btn-danger" onclick="delete100PercentDuplicates()">删除100%重复题</button>
            </div>
            <div>
                <button class="btn" onclick="this.parentNode.parentNode.parentNode.style.display='none'">关闭</button>
            </div>
        </div>
    `;
    
    modalContent.innerHTML = html;
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // 点击模态框外部关闭
    modal.onclick = function(e) {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    };
}

// 更新选中状态
function updateDuplicateSelection(index, isChecked) {
    duplicateResults[index].checked = isChecked;
}

// 全选/取消全选
function selectAllDuplicates(select) {
    duplicateResults.forEach(dup => {
        dup.checked = select;
    });
    
    // 更新界面复选框状态
    document.querySelectorAll('.duplicate-checkbox').forEach(checkbox => {
        checkbox.checked = select;
    });
}

function deleteSelectedDuplicates() {
    const selectedIds = duplicateResults
        .filter(dup => dup.checked)
        .map(dup => dup.id2);
    
    if (selectedIds.length === 0) {
        alert('请至少选择一组要删除的重复题');
        return;
    }
    
    if (!confirm(`确定要删除 ${selectedIds.length} 道重复题目吗？`)) {
        return;
    }
    
    // 记录操作历史
    const deletedQuestions = questionBank.filter(q => selectedIds.includes(q.id));
    addHistory('bulkDelete', deletedQuestions, null);
    
    // 执行删除
    questionBank = questionBank.filter(q => !selectedIds.includes(q.id));
    
    // 重新编号所有题目（从1开始连续编号）
    questionBank = questionBank.map((q, index) => ({
        ...q,
        id: index + 1
    }));
    
    filteredQuestions = [...questionBank];
    
    // 刷新界面
    refreshAfterDelete();
}

function delete100PercentDuplicates() {
    const perfectDupIds = duplicateResults
        .filter(dup => dup.similarity === 1)
        .map(dup => dup.id2);
    
    if (perfectDupIds.length === 0) {
        alert('没有找到100%重复的题目');
        return;
    }
    
    if (!confirm(`确定要删除 ${perfectDupIds.length} 道100%重复的题目吗？`)) {
        return;
    }
    
    // 记录操作历史
    const deletedQuestions = questionBank.filter(q => perfectDupIds.includes(q.id));
    addHistory('bulkDelete', deletedQuestions, null);
    
    // 执行删除
    questionBank = questionBank.filter(q => !perfectDupIds.includes(q.id));
    
    // 重新编号所有题目（从1开始连续编号）
    questionBank = questionBank.map((q, index) => ({
        ...q,
        id: index + 1
    }));
    
    filteredQuestions = [...questionBank];
    
    // 刷新界面
    refreshAfterDelete();
}

function refreshAfterDelete() {
    renderQuestionTable();
    updateCategoryFilter();
    
    // 关闭查重窗口
    const modal = document.querySelector('.modal');
    if (modal) modal.style.display = 'none';
    
    // 重新查重
    checkDuplicates();
}

// 开始批量编辑
function startBulkEdit() {
    isBulkEditMode = true;
    selectedQuestions = [];
    document.getElementById('bulkEditControls').style.display = 'flex';
    document.getElementById('categoryEditContainer').style.display = 'none'; // 默认隐藏分类修改
    document.getElementById('undoBtn').disabled = true;
    
    // 更新批量操作下拉菜单
    const bulkEditAction = document.getElementById('bulkEditAction');
    bulkEditAction.innerHTML = `
        <option value="changeCategory">修改分类</option>
        <option value="delete">删除题目</option>
    `;
    
    // 添加下拉菜单变更事件
    bulkEditAction.onchange = function() {
        document.getElementById('categoryEditContainer').style.display = 
            this.value === 'changeCategory' ? 'block' : 'none';
    };
    
    renderQuestionTable();
}

// 全选题目
function selectAllForBulkEdit() {
    selectedQuestions = filteredQuestions.map(q => q.id);
    updateSelectedCount();
    renderQuestionTable();
}

// 取消全选题目
function deselectAllForBulkEdit() {
    selectedQuestions = [];
    updateSelectedCount();
    renderQuestionTable();
}

// 切换题目选择状态
function toggleQuestionSelection(questionId) {
    const index = selectedQuestions.indexOf(questionId);
    if (index === -1) {
        selectedQuestions.push(questionId);
    } else {
        selectedQuestions.splice(index, 1);
    }
}

// 更新已选择题目计数
function updateSelectedCount() {
    document.getElementById('selectedCount').textContent = `已选择 ${selectedQuestions.length} 个题目`;
}

// 应用批量编辑
function applyBulkEdit() {
    if (selectedQuestions.length === 0) {
        alert('请至少选择一道题目');
        return;
    }
    
    const action = document.getElementById('bulkEditAction').value;
    
    // 记录操作前的状态
    const oldQuestions = questionBank.filter(q => selectedQuestions.includes(q.id));
    
    if (action === 'changeCategory') {
        let newCategory = document.getElementById('newCategory').value;
        const newCategoryInput = document.getElementById('newCategoryInput').value.trim();
        
        if (newCategoryInput) {
            newCategory = newCategoryInput;
        }
        
        if (!newCategory) {
            alert('请选择或输入分类名称');
            return;
        }
        
        // 去掉括号和题目数量部分
        newCategory = newCategory.replace(/$\d+题$$/, '').trim();
        
        // 更新题目分类
        questionBank.forEach(q => {
            if (selectedQuestions.includes(q.id)) {
                q.category = newCategory;
            }
        });
        
        // 记录操作历史
        addHistory('bulkUpdate', oldQuestions, {
            action: 'changeCategory',
            newCategory: newCategory,
            questionIds: [...selectedQuestions]
        });
        
        alert(`成功将 ${selectedQuestions.length} 道题目的分类修改为 ${newCategory}`);
    } else if (action === 'delete') {
        if (confirm(`确定要删除这 ${selectedQuestions.length} 道题目吗？`)) {
            // 记录操作历史
            addHistory('bulkDelete', oldQuestions, null);
            
            // 执行批量删除
            questionBank = questionBank.filter(q => !selectedQuestions.includes(q.id));
            filteredQuestions = filteredQuestions.filter(q => !selectedQuestions.includes(q.id));
            
            alert(`成功删除 ${selectedQuestions.length} 道题目`);
        } else {
            return;
        }
    }
    
    // 重置批量编辑状态
    cancelBulkEdit();
    renderQuestionTable();
    updateCategoryFilter();
}

// 取消批量编辑
function cancelBulkEdit() {
    isBulkEditMode = false;
    selectedQuestions = [];
    document.getElementById('bulkEditControls').style.display = 'none';
    document.getElementById('undoBtn').disabled = history.length === 0;
    renderQuestionTable();
}

// 添加操作历史
function addHistory(action, oldData, newData) {
    history.push({
        timestamp: new Date(),
        action: action,
        oldData: oldData,
        newData: newData
    });
    
    updateHistoryButton();
    
    // 限制历史记录数量
    if (history.length > 50) {
        history.shift();
    }
}

// 更新撤销按钮状态
function updateHistoryButton() {
    document.getElementById('undoBtn').disabled = history.length === 0;
}

// 显示历史记录
function showHistory() {
    const historyList = document.getElementById('historyList');
    historyList.innerHTML = '';
    
    // 按时间倒序显示
    [...history].reverse().forEach((record, index) => {
        const historyItem = document.createElement('div');
        historyItem.className = 'history-item';
        
        let description = '';
        const timeStr = record.timestamp.toLocaleString();
        
        switch (record.action) {
            case 'add':
                description = `${timeStr} - 添加题目: ${record.newData.question}`;
                break;
            case 'update':
                description = `${timeStr} - 修改题目: ${record.oldData.question}`;
                break;
            case 'delete':
                description = `${timeStr} - 删除题目: ${record.oldData.question}`;
                break;
            case 'bulkUpdate':
                description = `${timeStr} - 批量修改: 修改了 ${record.newData.questionIds.length} 道题目的分类为 ${record.newData.newCategory}`;
                break;
            case 'bulkDelete':
                description = `${timeStr} - 批量删除: 删除了 ${record.oldData.length} 道题目`;
                break;
            case 'batchAdd':
                description = `${timeStr} - 批量添加: 添加了 ${record.newData.length} 道题目`;
                break;
        }
        
        historyItem.textContent = description;
        historyItem.onclick = function() {
            undoAction(history.length - 1 - index);
        };
        
        historyList.appendChild(historyItem);
    });
    
    document.getElementById('historyModal').style.display = 'block';
}

// 关闭历史记录模态框
function closeHistoryModal() {
    document.getElementById('historyModal').style.display = 'none';
}

// 清空历史记录
function clearHistory() {
    history = [];
    updateHistoryButton();
    closeHistoryModal();
}

// 撤销操作
function undoAction(index) {
    if (index < 0 || index >= history.length) return;
    
    const record = history[index];
    
    switch (record.action) {
        case 'add':
            // 撤销添加：删除题目
            questionBank = questionBank.filter(q => q.id !== record.newData.id);
            break;
        case 'update':
            // 撤销修改：恢复旧数据
            const updateIndex = questionBank.findIndex(q => q.id === record.oldData.id);
            if (updateIndex !== -1) {
                questionBank[updateIndex] = {...record.oldData};
            }
            break;
        case 'delete':
            // 撤销删除：恢复题目
            questionBank.push({...record.oldData});
            break;
        case 'bulkUpdate':
            // 撤销批量修改：恢复旧分类
            record.oldData.forEach(oldQuestion => {
                const qIndex = questionBank.findIndex(q => q.id === oldQuestion.id);
                if (qIndex !== -1) {
                    questionBank[qIndex].category = oldQuestion.category;
                }
            });
            break;
        case 'bulkDelete':
            // 撤销批量删除：恢复所有题目
            questionBank.push(...record.oldData);
            break;
        case 'batchAdd':
            // 撤销批量添加：删除所有添加的题目
            const newIds = record.newData.map(q => q.id);
            questionBank = questionBank.filter(q => !newIds.includes(q.id));
            break;
    }
    
    // 从历史记录中移除该操作
    history.splice(index, 1);
    
    // 更新界面
    filteredQuestions = [...questionBank];
    renderQuestionTable();
    updateCategoryFilter();
    updateHistoryButton();
    closeHistoryModal();
    
    alert('操作已撤销');
}
    </script>
</body>
</html>